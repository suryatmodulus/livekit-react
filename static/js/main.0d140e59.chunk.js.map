{"version":3,"sources":["../../src/components/AudioRenderer.tsx","../../src/components/ControlButton.tsx","../../src/components/AudioSelectButton.tsx","../../src/useParticipant.ts","../../src/components/VideoSelectButton.tsx","../../src/components/ControlsView.tsx","../../src/components/DisplayContext.tsx","../../src/components/VideoRenderer.tsx","../../src/components/ParticipantView.tsx","../../src/components/ScreenShareView.tsx","../../src/components/desktop/GridStage.tsx","../../src/components/desktop/SpeakerStage.tsx","../../src/components/mobile/MobileStage.tsx","../../src/components/StageView.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../../src/useRoom.ts","../../src/LiveKitRoom.tsx","PreJoinPage.tsx","RoomPage.tsx","App.tsx","index.tsx"],"names":["AudioRenderer","track","isLocal","audioEl","useRef","useEffect","el","ControlButton","label","disabled","onClick","icon","className","menuItems","popoverContainerClassName","popoverTriggerBtnClassName","popoverTriggerBtnSeparatorClassName","onMenuItemClick","useState","menuVisible","setMenuVisible","classes","styles","menu","React","menuTrigger","dropdown","height","faChevronDown","list","key","i","item","handleMenuClick","mainContent","isOpen","positions","content","buttonWrapper","AudioSelectButton","isMuted","onSourceSelected","isButtonDisabled","muteText","unmuteText","sources","setSources","setMenuItems","listAudioDevices","useCallback","Room","devices","navigator","faMicrophone","device","d","useParticipant","participant","isAudioMuted","setAudioMuted","setVideoMuted","connectionQuality","setConnectionQuality","isSpeaking","setSpeaking","metadata","setMetadata","publications","setPublications","subscribedTracks","setSubscribedTracks","onPublicationsChanged","Array","pub","onMuted","Track","onUnmuted","onMetadataChanged","onIsSpeakingChanged","onConnectionQualityUpdate","ParticipantEvent","muted","cameraPublication","microphonePublication","screenSharePublication","VideoSelectButton","isEnabled","disableText","enableText","listVideoDevices","faVideoSlash","ControlsView","room","enableScreenShare","enableAudio","enableVideo","onLeave","camPub","audioButtonDisabled","setAudioButtonDisabled","enabled","muteButton","videoButtonDisabled","setVideoButtonDisabled","videoButton","screenButtonDisabled","setScreenButtonDisabled","screenButton","faDesktop","controlsWrapper","dangerButton","DisplayContext","stageLayout","showStats","VideoRenderer","objectFit","onSizeChanged","width","ref","handleResize","ev","isFrontFacing","style","transform","video","ParticipantView","speakerClassName","aspectWidth","aspectHeight","orientation","displayName","showOverlay","showConnectionQuality","onMouseEnter","onMouseLeave","videoSize","setVideoSize","currentBitrate","setCurrentBitrate","context","useContext","interval","setInterval","total","clearInterval","containerStyles","videoOrientation","mainElement","placeholder","statsContent","stats","Math","ConnectionQuality","ConnectionQualityIndicator","ratio","participantBar","name","center","iconNormal","ScreenShareView","screenShare","GridStage","roomState","participantRenderer","controlRenderer","isConnecting","error","participants","visibleParticipants","setVisibleParticipants","setShowOverlay","gridClass","setGridClass","numVisible","newParticipants","p","speaker","idx","ParticipantRenderer","ControlRenderer","identity","SpeakerStage","screenTrack","otherParticipants","mainView","MobileStage","StageView","stageProps","isMobile","useMediaQuery","query","container","sid","overlay","unmuteButton","size","faVolumeMute","Symbol","iterator","asyncIterator","sortParticipants","localParticipant","a","b","aLast","aVideo","localIdx","LiveKitRoom","url","token","connectOptions","stageRenderer","onConnected","options","setRoom","setIsConnecting","setError","setParticipants","audioTracks","setAudioTracks","sortFunc","connectFn","body","recover","result","e","then","connect","onParticipantsChanged","remotes","newRoom","onSubscribedTrackChanged","tracks","RoomEvent","setTimeout","Error","useRoom","PreJoinPage","setUrl","setToken","simulcast","setSimulcast","dynacast","setDynacast","adaptiveStream","setAdaptiveStream","videoEnabled","setVideoEnabled","audioEnabled","setAudioEnabled","connectDisabled","setConnectDisabled","videoTrack","setVideoTrack","audioDevice","setAudioDevice","videoDevice","setVideoDevice","history","useHistory","toggleVideo","stop","undefined","createLocalVideoTrack","deviceId","videoElement","connectToRoom","window","location","protocol","startsWith","alert","params","audioDeviceId","videoDeviceId","getDeviceId","push","pathname","search","URLSearchParams","toString","type","value","onChange","target","id","checked","htmlFor","mediaStreamTrack","getSettings","faBolt","href","RoomPage","numParticipants","setNumParticipants","displayOptions","setDisplayOptions","useLocation","get","recorder","updateParticipantSize","updateOptions","Provider","faThLarge","faSquare","faUserFriends","on","ParticipantConnected","ParticipantDisconnected","parseInt","console","log","onParticipantDisconnected","isSet","videoCaptureDefaults","resolution","VideoPresets","h720","logLevel","currentRoom","audioCaptureDefaults","setMicrophoneEnabled","setCameraEnabled","App","path","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0d140e59.chunk.js","sourcesContent":["import { Track } from \"livekit-client\";\nimport { useEffect, useRef } from \"react\";\n\nexport interface AudioTrackProps {\n  track: Track;\n  isLocal: boolean;\n}\n\nexport const AudioRenderer = ({ track, isLocal }: AudioTrackProps) => {\n  const audioEl = useRef<HTMLAudioElement>();\n\n  useEffect(() => {\n    if (isLocal) {\n      // don't play own audio\n      return;\n    }\n    audioEl.current = track.attach();\n    if (track.sid) {\n      audioEl.current.setAttribute(\"data-audio-track-id\", track.sid);\n    }\n    return () => track.detach().forEach((el) => el.remove());\n  }, [track, isLocal]);\n\n  // TODO: allow set sink id\n  return null;\n};\n","import { IconDefinition } from \"@fortawesome/fontawesome-svg-core\";\nimport { faChevronDown } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport React, { ReactElement, useState } from \"react\";\nimport { Popover } from \"react-tiny-popover\";\nimport styles from \"./styles.module.css\";\n\ninterface ButtonProps {\n  label: string;\n  disabled?: boolean;\n  onClick?: () => void;\n  icon?: IconDefinition;\n  className?: string;\n  popoverContainerClassName?: string;\n  popoverTriggerBtnClassName?: string;\n  popoverTriggerBtnSeparatorClassName?: string;\n  menuItems?: MenuItem[];\n  onMenuItemClick?: (item: MenuItem) => void;\n}\n\nexport interface MenuItem {\n  label: string;\n}\n\nexport const ControlButton = ({\n  label,\n  disabled,\n  onClick,\n  icon,\n  className,\n  menuItems,\n  popoverContainerClassName,\n  popoverTriggerBtnClassName,\n  popoverTriggerBtnSeparatorClassName,\n  onMenuItemClick,\n}: ButtonProps) => {\n  const [menuVisible, setMenuVisible] = useState(false);\n\n  let classes = styles.button;\n  if (className) {\n    classes += ` ${className}`;\n  }\n\n  const handleMenuClick = (item: MenuItem) => {\n    setMenuVisible(false);\n    if (onMenuItemClick) {\n      onMenuItemClick(item);\n    }\n  };\n\n  let menuTrigger: ReactElement | undefined;\n  let menu: ReactElement = <div />;\n  if (menuItems && menuItems.length > 0) {\n    classes += ` ${styles.hasDropdown}`;\n    menuTrigger = (\n      <button\n        disabled={disabled}\n        className={`${styles.button} ${popoverTriggerBtnClassName}  ${styles.dropdown}`}\n        onClick={() => setMenuVisible(!menuVisible)}\n      >\n        <div\n          className={`${styles.separator} ${popoverTriggerBtnSeparatorClassName}`}\n        />\n        <FontAwesomeIcon height={32} icon={faChevronDown} />\n      </button>\n    );\n\n    menu = (\n      <div className={`${styles.popoverMenu} ${popoverContainerClassName}`}>\n        <ul className={styles.list}>\n          {menuItems?.map((item, i) => {\n            return (\n              <li key={i} onClick={() => handleMenuClick(item)}>\n                {item.label}\n              </li>\n            );\n          })}\n        </ul>\n      </div>\n    );\n  }\n\n  const mainContent = (\n    <button\n      disabled={disabled}\n      className={classes}\n      onClick={() => {\n        setMenuVisible(false);\n        if (onClick) onClick();\n      }}\n    >\n      {icon && (\n        <FontAwesomeIcon className={styles.icon} height={32} icon={icon} />\n      )}\n      {label}\n    </button>\n  );\n\n  if (!menuTrigger) {\n    return mainContent;\n  }\n\n  return (\n    <Popover isOpen={menuVisible} positions={[\"top\"]} content={menu}>\n      <div className={styles.buttonWrapper}>\n        {mainContent}\n        {menuTrigger}\n      </div>\n    </Popover>\n  );\n};\n","import {\n  faMicrophone,\n  faMicrophoneSlash,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { Room } from \"livekit-client\";\nimport React, { useCallback, useEffect, useState } from \"react\";\nimport { ControlButton, MenuItem } from \"./ControlButton\";\n\nexport interface AudioSelectButtonProps {\n  isMuted: boolean;\n  onClick?: () => void;\n  onSourceSelected?: (device: MediaDeviceInfo) => void;\n  isButtonDisabled?: boolean;\n  muteText?: string;\n  unmuteText?: string;\n  className?: string;\n  popoverContainerClassName?: string;\n  popoverTriggerBtnClassName?: string;\n  popoverTriggerBtnSeparatorClassName?: string;\n}\n\nexport const AudioSelectButton = ({\n  isMuted,\n  onClick,\n  onSourceSelected,\n  isButtonDisabled,\n  muteText = \"Mute\",\n  unmuteText = \"Unmute\",\n  className,\n  popoverContainerClassName,\n  popoverTriggerBtnClassName,\n  popoverTriggerBtnSeparatorClassName,\n}: AudioSelectButtonProps) => {\n  const [sources, setSources] = useState<MediaDeviceInfo[]>([]);\n  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);\n\n  const listAudioDevices = useCallback(async () => {\n    const devices = await Room.getLocalDevices(\"audioinput\");\n    setSources(devices);\n    setMenuItems(\n      devices.map((item) => {\n        return { label: item.label };\n      })\n    );\n  }, []);\n\n  useEffect(() => {\n    listAudioDevices();\n    navigator.mediaDevices.addEventListener(\"devicechange\", listAudioDevices);\n\n    return () => {\n      navigator.mediaDevices.removeEventListener(\n        \"devicechange\",\n        listAudioDevices\n      );\n    };\n  }, []);\n\n  const handleMenuItem = (item: MenuItem) => {\n    const device = sources.find((d) => d.label === item.label);\n    if (device && onSourceSelected) {\n      onSourceSelected(device);\n    }\n  };\n\n  return (\n    <ControlButton\n      label={isMuted ? unmuteText : muteText}\n      icon={isMuted ? faMicrophoneSlash : faMicrophone}\n      disabled={isButtonDisabled}\n      onClick={onClick}\n      menuItems={menuItems}\n      onMenuItemClick={handleMenuItem}\n      className={className}\n      popoverContainerClassName={popoverContainerClassName}\n      popoverTriggerBtnClassName={popoverTriggerBtnClassName}\n      popoverTriggerBtnSeparatorClassName={popoverTriggerBtnSeparatorClassName}\n    />\n  );\n};\n","import {\n  ConnectionQuality,\n  LocalParticipant,\n  Participant,\n  ParticipantEvent,\n  Track,\n  TrackPublication,\n} from \"livekit-client\";\nimport { useEffect, useState } from \"react\";\n\nexport interface ParticipantState {\n  isSpeaking: boolean;\n  connectionQuality: ConnectionQuality;\n  isLocal: boolean;\n  metadata?: string;\n  publications: TrackPublication[];\n  subscribedTracks: TrackPublication[];\n  cameraPublication?: TrackPublication;\n  microphonePublication?: TrackPublication;\n  screenSharePublication?: TrackPublication;\n}\n\nexport function useParticipant(participant: Participant): ParticipantState {\n  const [isAudioMuted, setAudioMuted] = useState(false);\n  const [, setVideoMuted] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState<ConnectionQuality>(\n    participant.connectionQuality\n  );\n  const [isSpeaking, setSpeaking] = useState(false);\n  const [metadata, setMetadata] = useState<string>();\n  const [publications, setPublications] = useState<TrackPublication[]>([]);\n  const [subscribedTracks, setSubscribedTracks] = useState<TrackPublication[]>(\n    []\n  );\n\n  const onPublicationsChanged = () => {\n    setPublications(Array.from(participant.tracks.values()));\n    setSubscribedTracks(\n      Array.from(participant.tracks.values()).filter((pub) => {\n        return pub.isSubscribed && pub.track !== undefined;\n      })\n    );\n  };\n\n  useEffect(() => {\n    const onMuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setAudioMuted(true);\n      } else if (pub.kind === Track.Kind.Video) {\n        setVideoMuted(true);\n      }\n    };\n    const onUnmuted = (pub: TrackPublication) => {\n      if (pub.kind === Track.Kind.Audio) {\n        setAudioMuted(false);\n      } else if (pub.kind === Track.Kind.Video) {\n        setVideoMuted(false);\n      }\n    };\n    const onMetadataChanged = () => {\n      if (participant.metadata) {\n        setMetadata(participant.metadata);\n      }\n    };\n    const onIsSpeakingChanged = () => {\n      setSpeaking(participant.isSpeaking);\n    };\n    const onConnectionQualityUpdate = () => {\n      setConnectionQuality(participant.connectionQuality);\n    };\n\n    // register listeners\n    participant\n      .on(ParticipantEvent.TrackMuted, onMuted)\n      .on(ParticipantEvent.TrackUnmuted, onUnmuted)\n      .on(ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged)\n      .on(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged)\n      .on(ParticipantEvent.TrackPublished, onPublicationsChanged)\n      .on(ParticipantEvent.TrackUnpublished, onPublicationsChanged)\n      .on(ParticipantEvent.TrackSubscribed, onPublicationsChanged)\n      .on(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged)\n      .on(ParticipantEvent.LocalTrackPublished, onPublicationsChanged)\n      .on(ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged)\n      .on(ParticipantEvent.ConnectionQualityChanged, onConnectionQualityUpdate);\n\n    // set initial state\n    onMetadataChanged();\n    onIsSpeakingChanged();\n    onPublicationsChanged();\n\n    return () => {\n      // cleanup\n      participant\n        .off(ParticipantEvent.TrackMuted, onMuted)\n        .off(ParticipantEvent.TrackUnmuted, onUnmuted)\n        .off(ParticipantEvent.ParticipantMetadataChanged, onMetadataChanged)\n        .off(ParticipantEvent.IsSpeakingChanged, onIsSpeakingChanged)\n        .off(ParticipantEvent.TrackPublished, onPublicationsChanged)\n        .off(ParticipantEvent.TrackUnpublished, onPublicationsChanged)\n        .off(ParticipantEvent.TrackSubscribed, onPublicationsChanged)\n        .off(ParticipantEvent.TrackUnsubscribed, onPublicationsChanged)\n        .off(ParticipantEvent.LocalTrackPublished, onPublicationsChanged)\n        .off(ParticipantEvent.LocalTrackUnpublished, onPublicationsChanged)\n        .off(\n          ParticipantEvent.ConnectionQualityChanged,\n          onConnectionQualityUpdate\n        );\n    };\n  }, [participant]);\n\n  let muted: boolean | undefined;\n  participant.audioTracks.forEach((pub) => {\n    muted = pub.isMuted;\n  });\n  if (muted === undefined) {\n    muted = true;\n  }\n  if (isAudioMuted !== muted) {\n    setAudioMuted(muted);\n  }\n\n  return {\n    isLocal: participant instanceof LocalParticipant,\n    isSpeaking,\n    connectionQuality,\n    publications,\n    subscribedTracks,\n    cameraPublication: participant.getTrack(Track.Source.Camera),\n    microphonePublication: participant.getTrack(Track.Source.Microphone),\n    screenSharePublication: participant.getTrack(Track.Source.ScreenShare),\n    metadata,\n  };\n}\n","import { faVideo, faVideoSlash } from \"@fortawesome/free-solid-svg-icons\";\nimport { Room } from \"livekit-client\";\nimport React, { useCallback, useEffect, useState } from \"react\";\nimport { ControlButton, MenuItem } from \"./ControlButton\";\n\nexport interface VideoSelectButtonProps {\n  isEnabled: boolean;\n  onClick?: () => void;\n  onSourceSelected?: (device: MediaDeviceInfo) => void;\n  disableText?: string;\n  enableText?: string;\n  className?: string;\n  isButtonDisabled?: boolean;\n  popoverContainerClassName?: string;\n  popoverTriggerBtnClassName?: string;\n  popoverTriggerBtnSeparatorClassName?: string;\n}\n\nexport const VideoSelectButton = ({\n  isEnabled,\n  onClick,\n  onSourceSelected,\n  disableText = \"Disable Video\",\n  enableText = \"Enable Video\",\n  className,\n  isButtonDisabled,\n  popoverContainerClassName,\n  popoverTriggerBtnClassName,\n  popoverTriggerBtnSeparatorClassName,\n}: VideoSelectButtonProps) => {\n  const [sources, setSources] = useState<MediaDeviceInfo[]>([]);\n  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);\n\n  const listVideoDevices = useCallback(async () => {\n    const devices = await Room.getLocalDevices(\"videoinput\");\n    setSources(devices);\n    setMenuItems(\n      devices.map((item) => {\n        return { label: item.label };\n      })\n    );\n  }, []);\n\n  useEffect(() => {\n    listVideoDevices();\n    navigator.mediaDevices.addEventListener(\"devicechange\", listVideoDevices);\n    return () => {\n      navigator.mediaDevices.removeEventListener(\n        \"devicechange\",\n        listVideoDevices\n      );\n    };\n  }, []);\n\n  const handleMenuItem = (item: MenuItem) => {\n    const device = sources.find((d) => d.label === item.label);\n    if (device && onSourceSelected) {\n      onSourceSelected(device);\n    }\n  };\n\n  return (\n    <ControlButton\n      label={isEnabled ? disableText : enableText}\n      icon={isEnabled ? faVideo : faVideoSlash}\n      disabled={isButtonDisabled}\n      onClick={onClick}\n      menuItems={menuItems}\n      onMenuItemClick={handleMenuItem}\n      className={className}\n      popoverContainerClassName={popoverContainerClassName}\n      popoverTriggerBtnClassName={popoverTriggerBtnClassName}\n      popoverTriggerBtnSeparatorClassName={popoverTriggerBtnSeparatorClassName}\n    />\n  );\n};\n","import { faDesktop, faStop } from \"@fortawesome/free-solid-svg-icons\";\nimport { Room } from \"livekit-client\";\nimport React, { ReactElement } from \"react\";\nimport { useParticipant } from \"../useParticipant\";\nimport { AudioSelectButton } from \"./AudioSelectButton\";\nimport { ControlButton } from \"./ControlButton\";\nimport styles from \"./styles.module.css\";\nimport { VideoSelectButton } from \"./VideoSelectButton\";\n\nexport interface ControlsProps {\n  room: Room;\n  enableScreenShare?: boolean;\n  enableAudio?: boolean;\n  enableVideo?: boolean;\n  onLeave?: (room: Room) => void;\n}\n\nexport const ControlsView = ({\n  room,\n  enableScreenShare,\n  enableAudio,\n  enableVideo,\n  onLeave,\n}: ControlsProps) => {\n  const { cameraPublication: camPub } = useParticipant(room.localParticipant);\n\n  if (enableScreenShare === undefined) {\n    enableScreenShare = true;\n  }\n  if (enableVideo === undefined) {\n    enableVideo = true;\n  }\n  if (enableAudio === undefined) {\n    enableAudio = true;\n  }\n\n  const [audioButtonDisabled, setAudioButtonDisabled] = React.useState(false);\n  let muteButton: ReactElement | undefined;\n  if (enableAudio) {\n    const enabled = room.localParticipant.isMicrophoneEnabled;\n    muteButton = (\n      <AudioSelectButton\n        isMuted={!enabled}\n        isButtonDisabled={audioButtonDisabled}\n        onClick={async () => {\n          setAudioButtonDisabled(true);\n          room.localParticipant.setMicrophoneEnabled(!enabled);\n          setAudioButtonDisabled(false);\n        }}\n        onSourceSelected={async (device) => {\n          setAudioButtonDisabled(true);\n          await room.switchActiveDevice(\"audioinput\", device.deviceId);\n          setAudioButtonDisabled(false);\n        }}\n      />\n    );\n  }\n\n  const [videoButtonDisabled, setVideoButtonDisabled] = React.useState(false);\n\n  let videoButton: ReactElement | undefined;\n  if (enableVideo) {\n    const enabled = !(camPub?.isMuted ?? true);\n    videoButton = (\n      <VideoSelectButton\n        isEnabled={enabled}\n        isButtonDisabled={videoButtonDisabled}\n        onClick={async () => {\n          setVideoButtonDisabled(true);\n          await room.localParticipant.setCameraEnabled(!enabled);\n          setVideoButtonDisabled(false);\n        }}\n        onSourceSelected={async (device) => {\n          setVideoButtonDisabled(true);\n          await room.switchActiveDevice(\"videoinput\", device.deviceId);\n          setVideoButtonDisabled(false);\n        }}\n      />\n    );\n  }\n\n  const [screenButtonDisabled, setScreenButtonDisabled] = React.useState(false);\n  let screenButton: ReactElement | undefined;\n  if (enableScreenShare) {\n    const enabled = room.localParticipant.isScreenShareEnabled;\n    screenButton = (\n      <ControlButton\n        label={enabled ? \"Stop sharing\" : \"Share screen\"}\n        icon={enabled ? faStop : faDesktop}\n        disabled={screenButtonDisabled}\n        onClick={async () => {\n          setScreenButtonDisabled(true);\n          await room.localParticipant.setScreenShareEnabled(!enabled);\n          setScreenButtonDisabled(false);\n        }}\n      />\n    );\n  }\n\n  return (\n    <div className={styles.controlsWrapper}>\n      {muteButton}\n      {videoButton}\n      {screenButton}\n      {onLeave && (\n        <ControlButton\n          label=\"End\"\n          className={styles.dangerButton}\n          onClick={() => {\n            room.disconnect();\n            onLeave(room);\n          }}\n        />\n      )}\n    </div>\n  );\n};\n","import React from \"react\";\n\nexport interface DisplayOptions {\n  stageLayout?: string;\n  /** display debugging stats */\n  showStats?: boolean;\n}\n\nexport const DisplayContext = React.createContext<DisplayOptions>({\n  stageLayout: \"grid\",\n  showStats: false,\n});\n","import { Property } from \"csstype\";\nimport { Track } from \"livekit-client\";\nimport React, { CSSProperties, useCallback, useEffect, useRef } from \"react\";\nimport styles from \"./styles.module.css\";\n\nexport interface VideoRendererProps {\n  track: Track;\n  isLocal: boolean;\n  objectFit?: Property.ObjectFit;\n  className?: string;\n  width?: Property.Width;\n  height?: Property.Height;\n  onSizeChanged?: (width: number, height: number) => void;\n}\n\nexport const VideoRenderer = ({\n  track,\n  isLocal,\n  objectFit,\n  className,\n  onSizeChanged,\n  width,\n  height,\n}: VideoRendererProps) => {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) {\n      return;\n    }\n    el.muted = true;\n    track.attach(el);\n    return () => {\n      track.detach(el);\n    };\n  }, [track, ref]);\n\n  const handleResize = useCallback((ev: UIEvent) => {\n    if (ev.target instanceof HTMLVideoElement) {\n      if (onSizeChanged) {\n        onSizeChanged(ev.target.videoWidth, ev.target.videoHeight);\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    const el = ref.current;\n    if (el) {\n      el.addEventListener(\"resize\", handleResize);\n    }\n    return () => {\n      el?.removeEventListener(\"resize\", handleResize);\n    };\n  }, [ref]);\n\n  const isFrontFacing =\n    track.mediaStreamTrack?.getSettings().facingMode !== \"environment\";\n  const style: CSSProperties = {\n    transform: isLocal && isFrontFacing ? \"rotateY(180deg)\" : \"\",\n    width: width,\n    height: height,\n  };\n  if (objectFit) {\n    style.objectFit = objectFit;\n  }\n\n  return (\n    <video ref={ref} className={className ?? styles.video} style={style} />\n  );\n};\n","import {\n  faMicrophone,\n  faMicrophoneSlash,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Property } from \"csstype\";\nimport {\n  ConnectionQuality,\n  LocalTrack,\n  Participant,\n  RemoteTrack,\n} from \"livekit-client\";\nimport React, {\n  CSSProperties,\n  ReactElement,\n  useCallback,\n  useContext,\n  useEffect,\n  useState,\n} from \"react\";\nimport { AspectRatio } from \"react-aspect-ratio\";\nimport { ReactComponent as connectionQuality1 } from \"../../static/connection-quality-1.svg\";\nimport { ReactComponent as connectionQuality2 } from \"../../static/connection-quality-2.svg\";\nimport { ReactComponent as connectionQuality3 } from \"../../static/connection-quality-3.svg\";\nimport { useParticipant } from \"../useParticipant\";\nimport { DisplayContext } from \"./DisplayContext\";\nimport styles from \"./styles.module.css\";\nimport { VideoRenderer } from \"./VideoRenderer\";\n\nexport interface ParticipantProps {\n  participant: Participant;\n  displayName?: string;\n  // width in CSS\n  width?: Property.Width;\n  // height in CSS\n  height?: Property.Height;\n  className?: string;\n  // aspect ratio width, if set, maintains aspect ratio\n  aspectWidth?: number;\n  // aspect ratio height\n  aspectHeight?: number;\n  // determine whether to contain or cover video.\n  // cover mode is used when layout orientation matches video orientation\n  orientation?: \"landscape\" | \"portrait\";\n  // true if overlay with participant info should be shown\n  showOverlay?: boolean;\n  // true if connection quality should be shown\n  showConnectionQuality?: boolean;\n  // additional classname when participant is currently speaking\n  speakerClassName?: string;\n  onMouseEnter?: () => void;\n  onMouseLeave?: () => void;\n  onClick?: () => void;\n}\n\nexport const ParticipantView = ({\n  participant,\n  width,\n  height,\n  className,\n  speakerClassName,\n  aspectWidth,\n  aspectHeight,\n  orientation,\n  displayName,\n  showOverlay,\n  showConnectionQuality,\n  onMouseEnter,\n  onMouseLeave,\n  onClick,\n}: ParticipantProps) => {\n  const { cameraPublication, isLocal, connectionQuality, isSpeaking } =\n    useParticipant(participant);\n  const [videoSize, setVideoSize] = useState<string>();\n  const [currentBitrate, setCurrentBitrate] = useState<number>();\n  const context = useContext(DisplayContext);\n\n  const handleResize = useCallback((width: number, height: number) => {\n    setVideoSize(`${width}x${height}`);\n  }, []);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      let total = 0;\n      participant.tracks.forEach((pub) => {\n        if (\n          pub.track instanceof LocalTrack ||\n          pub.track instanceof RemoteTrack\n        ) {\n          total += pub.track.currentBitrate;\n        }\n      });\n      setCurrentBitrate(total);\n    }, 1000);\n    return () => {\n      clearInterval(interval);\n    };\n  }, []);\n\n  const containerStyles: CSSProperties = {\n    width: width,\n    height: height,\n  };\n\n  // when aspect matches, cover instead\n  let objectFit: Property.ObjectFit = \"contain\";\n  let videoOrientation: \"landscape\" | \"portrait\" | undefined;\n  if (!orientation && aspectWidth && aspectHeight) {\n    orientation = aspectWidth > aspectHeight ? \"landscape\" : \"portrait\";\n  }\n  if (cameraPublication?.dimensions) {\n    videoOrientation =\n      cameraPublication.dimensions.width > cameraPublication.dimensions.height\n        ? \"landscape\"\n        : \"portrait\";\n  }\n\n  if (videoOrientation === orientation) {\n    objectFit = \"cover\";\n  }\n\n  if (!displayName) {\n    displayName = participant.name || participant.identity;\n    if (isLocal) {\n      displayName += \" (You)\";\n    }\n  }\n\n  let mainElement: ReactElement;\n  if (\n    cameraPublication?.isSubscribed &&\n    cameraPublication?.track &&\n    !cameraPublication?.isMuted\n  ) {\n    mainElement = (\n      <VideoRenderer\n        track={cameraPublication.track}\n        isLocal={isLocal}\n        objectFit={objectFit}\n        width=\"100%\"\n        height=\"100%\"\n        onSizeChanged={handleResize}\n      />\n    );\n  } else {\n    mainElement = <div className={styles.placeholder} />;\n  }\n\n  const classes = [styles.participant];\n  if (className) {\n    classes.push(className);\n  }\n  if (isSpeaking) {\n    classes.push(speakerClassName ?? styles.speaker);\n  }\n  const isAudioMuted = !participant.isMicrophoneEnabled;\n\n  // gather stats\n  let statsContent: ReactElement | undefined;\n  if (context.showStats) {\n    statsContent = (\n      <div className={styles.stats}>\n        <span>{videoSize}</span>\n        {currentBitrate !== undefined && currentBitrate > 0 && (\n          <span>&nbsp;{Math.round(currentBitrate / 1024)} kbps</span>\n        )}\n      </div>\n    );\n  }\n\n  let ConnectionQualityIndicator: typeof connectionQuality1 | undefined;\n  if (showConnectionQuality) {\n    switch (connectionQuality) {\n      case ConnectionQuality.Excellent:\n        ConnectionQualityIndicator = connectionQuality3;\n        break;\n      case ConnectionQuality.Good:\n        ConnectionQualityIndicator = connectionQuality2;\n        break;\n      case ConnectionQuality.Poor:\n        ConnectionQualityIndicator = connectionQuality1;\n        break;\n    }\n  }\n\n  return (\n    <div\n      className={classes.join(\" \")}\n      style={containerStyles}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      onClick={onClick}\n    >\n      {aspectWidth && aspectHeight && (\n        <AspectRatio ratio={aspectWidth / aspectHeight}>\n          {mainElement}\n        </AspectRatio>\n      )}\n      {(!aspectWidth || !aspectHeight) && mainElement}\n\n      {(showOverlay || context.showStats) && (\n        <div className={styles.participantBar}>\n          <div className={styles.name}>{displayName}</div>\n          <div className={styles.center}>{statsContent}</div>\n          <div>\n            {ConnectionQualityIndicator && <ConnectionQualityIndicator />}\n          </div>\n          <div>\n            <FontAwesomeIcon\n              icon={isAudioMuted ? faMicrophoneSlash : faMicrophone}\n              height={24}\n              className={isAudioMuted ? styles.iconRed : styles.iconNormal}\n            />\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n","import { Property } from \"csstype\";\nimport { Track } from \"livekit-client\";\nimport React from \"react\";\nimport styles from \"./styles.module.css\";\nimport { VideoRenderer } from \"./VideoRenderer\";\n\ninterface ScreenShareProps {\n  track: Track;\n  width?: Property.Width;\n  height?: Property.Height;\n}\n\nexport const ScreenShareView = ({ track, width, height }: ScreenShareProps) => {\n  return (\n    <div className={styles.screenShare}>\n      <VideoRenderer\n        track={track}\n        isLocal={false}\n        width={width}\n        height={height}\n      />\n    </div>\n  );\n};\n","import { Participant } from \"livekit-client\";\nimport React, { useEffect, useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const GridStage = ({\n  roomState,\n  participantRenderer,\n  controlRenderer,\n  onLeave,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [visibleParticipants, setVisibleParticipants] = useState<Participant[]>(\n    []\n  );\n  const [showOverlay, setShowOverlay] = useState(false);\n  const [gridClass, setGridClass] = React.useState(styles.grid1x1);\n\n  // compute visible participants and sort.\n  useEffect(() => {\n    // determine grid size\n    let numVisible = 1;\n    if (participants.length === 1) {\n      setGridClass(styles.grid1x1);\n    } else if (participants.length === 2) {\n      setGridClass(styles.grid2x1);\n      numVisible = 2;\n    } else if (participants.length <= 4) {\n      setGridClass(styles.grid2x2);\n      numVisible = Math.min(participants.length, 4);\n    } else if (participants.length <= 9) {\n      setGridClass(styles.grid3x3);\n      numVisible = Math.min(participants.length, 9);\n    } else if (participants.length <= 16) {\n      setGridClass(styles.grid4x4);\n      numVisible = Math.min(participants.length, 16);\n    } else {\n      setGridClass(styles.grid5x5);\n      numVisible = Math.min(participants.length, 25);\n    }\n\n    // remove any participants that are no longer connected\n    const newParticipants: Participant[] = [];\n    visibleParticipants.forEach((p) => {\n      if (\n        room?.participants.has(p.sid) ||\n        room?.localParticipant.sid === p.sid\n      ) {\n        newParticipants.push(p);\n      }\n    });\n\n    // ensure active speakers are all visible\n    room?.activeSpeakers?.forEach((speaker) => {\n      if (\n        newParticipants.includes(speaker) ||\n        (speaker !== room?.localParticipant &&\n          !room?.participants.has(speaker.sid))\n      ) {\n        return;\n      }\n      // find a non-active speaker and switch\n      const idx = newParticipants.findIndex((p) => !p.isSpeaking);\n      if (idx >= 0) {\n        newParticipants[idx] = speaker;\n      } else {\n        newParticipants.push(speaker);\n      }\n    });\n\n    // add other non speakers\n    for (const p of participants) {\n      if (newParticipants.length >= numVisible) {\n        break;\n      }\n      if (newParticipants.includes(p) || p.isSpeaking) {\n        continue;\n      }\n      newParticipants.push(p);\n    }\n\n    if (newParticipants.length > numVisible) {\n      newParticipants.splice(numVisible, newParticipants.length - numVisible);\n    }\n    setVisibleParticipants(newParticipants);\n  }, [participants]);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  const ControlRenderer = controlRenderer ?? ControlsView;\n\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={`${styles.gridStage} ${gridClass}`}>\n        {visibleParticipants.map((participant) => {\n          return (\n            <ParticipantRenderer\n              key={participant.identity}\n              participant={participant}\n              orientation=\"landscape\"\n              width=\"100%\"\n              height=\"100%\"\n              showOverlay={showOverlay}\n              showConnectionQuality\n              onMouseEnter={() => setShowOverlay(true)}\n              onMouseLeave={() => setShowOverlay(false)}\n            />\n          );\n        })}\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlRenderer room={room} onLeave={onLeave} />\n      </div>\n    </div>\n  );\n};\n","import { Track, VideoTrack } from \"livekit-client\";\nimport React, { ReactElement, useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { ScreenShareView } from \"../ScreenShareView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const SpeakerStage = ({\n  roomState,\n  participantRenderer,\n  controlRenderer,\n  onLeave,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  const ControlRenderer = controlRenderer ?? ControlsView;\n\n  // find first participant with screen shared\n  let screenTrack: VideoTrack | undefined;\n  participants.forEach((p) => {\n    if (screenTrack) {\n      return;\n    }\n    const track = p.getTrack(Track.Source.ScreenShare);\n    if (track?.isSubscribed && track.videoTrack) {\n      screenTrack = track.videoTrack;\n    }\n  });\n\n  const otherParticipants = participants;\n  let mainView: ReactElement;\n  if (screenTrack) {\n    mainView = (\n      <ScreenShareView track={screenTrack} height=\"100%\" width=\"100%\" />\n    );\n  } else {\n    mainView = (\n      <ParticipantRenderer\n        key={participants[0].identity}\n        participant={participants[0]}\n        width=\"100%\"\n        height=\"100%\"\n        orientation=\"landscape\"\n        showOverlay={showOverlay}\n        showConnectionQuality\n        onMouseEnter={() => setShowOverlay(true)}\n        onMouseLeave={() => setShowOverlay(false)}\n      />\n    );\n  }\n\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={styles.stage}>\n        <div className={styles.stageCenter}>{mainView}</div>\n        <div className={styles.sidebar}>\n          {otherParticipants.map((participant) => {\n            return (\n              <ParticipantRenderer\n                key={participant.identity}\n                participant={participant}\n                width=\"100%\"\n                aspectWidth={16}\n                aspectHeight={9}\n                showOverlay={showOverlay}\n                onMouseEnter={() => setShowOverlay(true)}\n                onMouseLeave={() => setShowOverlay(false)}\n              />\n            );\n          })}\n        </div>\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlRenderer room={room} onLeave={onLeave} />\n      </div>\n    </div>\n  );\n};\n","import { Track, VideoTrack } from \"livekit-client\";\nimport React, { ReactElement, useState } from \"react\";\nimport { ControlsView } from \"../ControlsView\";\nimport { ParticipantView } from \"../ParticipantView\";\nimport { ScreenShareView } from \"../ScreenShareView\";\nimport { StageProps } from \"../StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const MobileStage = ({\n  roomState,\n  participantRenderer,\n  controlRenderer,\n  onLeave,\n}: StageProps) => {\n  const { isConnecting, error, participants, room } = roomState;\n  const [showOverlay, setShowOverlay] = useState(false);\n\n  if (error) {\n    return <div>error {error.message}</div>;\n  }\n\n  if (isConnecting) {\n    return <div>connecting</div>;\n  }\n  if (!room) {\n    return <div>room closed</div>;\n  }\n\n  if (participants.length === 0) {\n    return <div>no one is in the room</div>;\n  }\n\n  const ParticipantRenderer = participantRenderer ?? ParticipantView;\n  const ControlRenderer = controlRenderer ?? ControlsView;\n\n  // find first participant with screen shared\n  let screenTrack: VideoTrack | undefined;\n  participants.forEach((p) => {\n    if (screenTrack) {\n      return;\n    }\n    const track = p.getTrack(Track.Source.ScreenShare);\n    if (track?.isSubscribed && track.videoTrack) {\n      screenTrack = track.videoTrack;\n    }\n  });\n\n  const otherParticipants = participants;\n  let mainView: ReactElement;\n  if (screenTrack) {\n    mainView = (\n      <ScreenShareView track={screenTrack} height=\"100%\" width=\"100%\" />\n    );\n  } else {\n    mainView = (\n      <ParticipantRenderer\n        key={participants[0].identity}\n        participant={participants[0]}\n        showOverlay={showOverlay}\n        width=\"100%\"\n        height=\"100%\"\n        orientation=\"portrait\"\n        showConnectionQuality\n        onMouseEnter={() => setShowOverlay(true)}\n        onMouseLeave={() => setShowOverlay(false)}\n      />\n    );\n  }\n\n  return (\n    // global container\n    <div className={styles.container}>\n      <div className={styles.stage}>{mainView}</div>\n      <div className={styles.participantsArea}>\n        {otherParticipants.map((participant) => {\n          return (\n            <ParticipantRenderer\n              key={participant.identity}\n              participant={participant}\n              className={styles.participant}\n              aspectWidth={4}\n              aspectHeight={3}\n              showOverlay={showOverlay}\n              onMouseEnter={() => setShowOverlay(true)}\n              onMouseLeave={() => setShowOverlay(false)}\n            />\n          );\n        })}\n      </div>\n      <div className={styles.controlsArea}>\n        <ControlRenderer\n          room={room}\n          enableScreenShare={false}\n          onLeave={onLeave}\n        />\n      </div>\n    </div>\n  );\n};\n","import { faVolumeMute } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { Track, VideoTrack } from \"livekit-client\";\nimport React, { ReactElement, useContext } from \"react\";\nimport { useMediaQuery } from \"react-responsive\";\nimport { AudioRenderer } from \"./AudioRenderer\";\nimport { GridStage } from \"./desktop/GridStage\";\nimport { SpeakerStage } from \"./desktop/SpeakerStage\";\nimport { DisplayContext } from \"./DisplayContext\";\nimport { MobileStage } from \"./mobile/MobileStage\";\nimport { StageProps } from \"./StageProps\";\nimport styles from \"./styles.module.css\";\n\nexport const StageView = (stageProps: StageProps) => {\n  const isMobile = useMediaQuery({ query: \"(max-width: 800px)\" });\n  const { room, participants } = stageProps.roomState;\n  const context = useContext(DisplayContext);\n\n  let mainElement: ReactElement;\n  if (isMobile) {\n    mainElement = <MobileStage {...stageProps} />;\n  } else {\n    // find first participant with screen shared\n    let screenTrack: VideoTrack | undefined;\n    participants.forEach((p) => {\n      if (screenTrack) {\n        return;\n      }\n      const track = p.getTrack(Track.Source.ScreenShare);\n      if (track?.isSubscribed && track.videoTrack) {\n        screenTrack = track.videoTrack;\n      }\n    });\n\n    if (context.stageLayout === \"grid\" && screenTrack === undefined) {\n      mainElement = <GridStage {...stageProps} />;\n    } else {\n      mainElement = <SpeakerStage {...stageProps} />;\n    }\n  }\n\n  return (\n    <div className={styles.container}>\n      {mainElement}\n      {stageProps.roomState.audioTracks.map((track) => (\n        <AudioRenderer key={track.sid} track={track} isLocal={false} />\n      ))}\n\n      {room?.canPlaybackAudio === false && (\n        <div className={styles.overlay}>\n          <button\n            className={styles.unmuteButton}\n            onClick={() => {\n              room.startAudio();\n            }}\n          >\n            <FontAwesomeIcon\n              className={styles.icon}\n              size=\"1x\"\n              icon={faVolumeMute}\n            />\n            Click to Unmute\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import {\n  AudioTrack,\n  connect,\n  ConnectOptions,\n  LocalParticipant,\n  Participant,\n  RemoteTrack,\n  Room,\n  RoomEvent,\n  Track,\n} from \"livekit-client\";\nimport { useCallback, useState } from \"react\";\n\nexport interface RoomState {\n  connect: (\n    url: string,\n    token: string,\n    options?: ConnectOptions\n  ) => Promise<Room | undefined>;\n  isConnecting: boolean;\n  room?: Room;\n  /* all participants in the room, including the local participant. */\n  participants: Participant[];\n  /* all subscribed audio tracks in the room, not including local participant. */\n  audioTracks: AudioTrack[];\n  error?: Error;\n}\n\nexport interface RoomOptions {\n  sortParticipants?: (participants: Participant[]) => void;\n}\n\nexport function useRoom(options?: RoomOptions): RoomState {\n  const [room, setRoom] = useState<Room>();\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [error, setError] = useState<Error>();\n  const [participants, setParticipants] = useState<Participant[]>([]);\n  const [audioTracks, setAudioTracks] = useState<AudioTrack[]>([]);\n\n  const sortFunc = options?.sortParticipants ?? sortParticipants;\n\n  const connectFn = useCallback(\n    async (url: string, token: string, options?: ConnectOptions) => {\n      setIsConnecting(true);\n      try {\n        const newRoom = await connect(url, token, options);\n        setRoom(newRoom);\n        const onParticipantsChanged = () => {\n          const remotes = Array.from(newRoom.participants.values());\n          const participants: Participant[] = [newRoom.localParticipant];\n          participants.push(...remotes);\n          sortFunc(participants, newRoom.localParticipant);\n          setParticipants(participants);\n        };\n        const onSubscribedTrackChanged = (track?: RemoteTrack) => {\n          // ordering may have changed, re-sort\n          onParticipantsChanged();\n          if (track && track.kind !== Track.Kind.Audio) {\n            return;\n          }\n          const tracks: AudioTrack[] = [];\n          newRoom.participants.forEach((p) => {\n            p.audioTracks.forEach((pub) => {\n              if (pub.audioTrack) {\n                tracks.push(pub.audioTrack);\n              }\n            });\n          });\n          setAudioTracks(tracks);\n        };\n\n        newRoom.once(RoomEvent.Disconnected, () => {\n          setTimeout(() => setRoom(undefined));\n\n          newRoom\n            .off(RoomEvent.ParticipantConnected, onParticipantsChanged)\n            .off(RoomEvent.ParticipantDisconnected, onParticipantsChanged)\n            .off(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged)\n            .off(RoomEvent.TrackSubscribed, onSubscribedTrackChanged)\n            .off(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged)\n            .off(RoomEvent.LocalTrackPublished, onParticipantsChanged)\n            .off(RoomEvent.LocalTrackUnpublished, onParticipantsChanged)\n            .off(RoomEvent.AudioPlaybackStatusChanged, onParticipantsChanged);\n        });\n        newRoom\n          .on(RoomEvent.ParticipantConnected, onParticipantsChanged)\n          .on(RoomEvent.ParticipantDisconnected, onParticipantsChanged)\n          .on(RoomEvent.ActiveSpeakersChanged, onParticipantsChanged)\n          .on(RoomEvent.TrackSubscribed, onSubscribedTrackChanged)\n          .on(RoomEvent.TrackUnsubscribed, onSubscribedTrackChanged)\n          .on(RoomEvent.LocalTrackPublished, onParticipantsChanged)\n          .on(RoomEvent.LocalTrackUnpublished, onParticipantsChanged)\n          // trigger a state change by re-sorting participants\n          .on(RoomEvent.AudioPlaybackStatusChanged, onParticipantsChanged);\n\n        setIsConnecting(false);\n        onSubscribedTrackChanged();\n\n        return newRoom;\n      } catch (error) {\n        setIsConnecting(false);\n        if (error instanceof Error) {\n          setError(error);\n        } else {\n          setError(new Error(\"an error has occured\"));\n        }\n\n        return undefined;\n      }\n    },\n    []\n  );\n\n  return {\n    connect: connectFn,\n    isConnecting,\n    room,\n    error,\n    participants,\n    audioTracks,\n  };\n}\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. dominant speaker (speaker with the loudest audio level)\n * 2. local participant\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(\n  participants: Participant[],\n  localParticipant?: LocalParticipant\n) {\n  participants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return b.audioLevel - a.audioLevel;\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      if (a.isSpeaking) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      const aLast = a.lastSpokeAt?.getTime() ?? 0;\n      const bLast = b.lastSpokeAt?.getTime() ?? 0;\n      return bLast - aLast;\n    }\n\n    // video on\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n  });\n\n  if (localParticipant) {\n    const localIdx = participants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      participants.splice(localIdx, 1);\n      if (participants.length > 0) {\n        participants.splice(1, 0, localParticipant);\n      } else {\n        participants.push(localParticipant);\n      }\n    }\n  }\n}\n","import { ConnectOptions, Participant, Room } from \"livekit-client\";\nimport React, { useEffect } from \"react\";\nimport { ControlsProps } from \"./components/ControlsView\";\nimport { ParticipantProps } from \"./components/ParticipantView\";\nimport { StageProps } from \"./components/StageProps\";\nimport { StageView } from \"./components/StageView\";\nimport { useRoom } from \"./useRoom\";\n\nexport interface RoomProps {\n  url: string;\n  token: string;\n  connectOptions?: ConnectOptions;\n  // override default participant sort\n  sortParticipants?: (participants: Participant[]) => void;\n  // when first connected to room\n  onConnected?: (room: Room) => void;\n  // when user leaves the room\n  onLeave?: (room: Room) => void;\n  stageRenderer?: (props: StageProps) => React.ReactElement | null;\n  participantRenderer?: (props: ParticipantProps) => React.ReactElement | null;\n  controlRenderer?: (props: ControlsProps) => React.ReactElement | null;\n}\n\nexport const LiveKitRoom = ({\n  url,\n  token,\n  connectOptions,\n  sortParticipants,\n  stageRenderer,\n  participantRenderer,\n  controlRenderer,\n  onConnected,\n  onLeave,\n}: RoomProps) => {\n  const roomState = useRoom({ sortParticipants });\n  if (!connectOptions) {\n    connectOptions = {};\n  }\n\n  useEffect(() => {\n    roomState.connect(url, token, connectOptions).then((room) => {\n      if (!room) {\n        return;\n      }\n      if (onConnected) {\n        onConnected(room);\n      }\n      return () => {\n        room.disconnect();\n      };\n    });\n  }, []);\n\n  const selectedStageRenderer = stageRenderer ?? StageView;\n\n  return selectedStageRenderer({\n    roomState,\n    participantRenderer,\n    controlRenderer,\n    onLeave,\n  });\n};\n","import { faBolt } from '@fortawesome/free-solid-svg-icons'\nimport { createLocalVideoTrack, LocalVideoTrack } from 'livekit-client'\nimport { AudioSelectButton, ControlButton, VideoRenderer, VideoSelectButton } from 'livekit-react'\nimport { ReactElement, useEffect, useState } from \"react\"\nimport { AspectRatio } from 'react-aspect-ratio'\nimport { useHistory } from 'react-router-dom'\n\nexport const PreJoinPage = () => {\n  // state to pass onto room\n  const [url, setUrl] = useState('ws://localhost:7880')\n  const [token, setToken] = useState<string>('')\n  const [simulcast, setSimulcast] = useState(true)\n  const [dynacast, setDynacast] = useState(true)\n  const [adaptiveStream, setAdaptiveStream] = useState(true)\n  const [videoEnabled, setVideoEnabled] = useState(false)\n  const [audioEnabled, setAudioEnabled] = useState(true)\n  // disable connect button unless validated\n  const [connectDisabled, setConnectDisabled] = useState(true)\n  const [videoTrack, setVideoTrack] = useState<LocalVideoTrack>();\n  const [audioDevice, setAudioDevice] = useState<MediaDeviceInfo>();\n  const [videoDevice, setVideoDevice] = useState<MediaDeviceInfo>();\n  const history = useHistory()\n\n  useEffect(() => {\n    if (token && url) {\n      setConnectDisabled(false)\n    } else {\n      setConnectDisabled(true)\n    }\n  }, [token, url])\n\n  const toggleVideo = async () => {\n    if (videoTrack) {\n      videoTrack.stop()\n      setVideoEnabled(false)\n      setVideoTrack(undefined)\n    } else {\n      const track = await createLocalVideoTrack({\n        deviceId: videoDevice?.deviceId,\n      })\n      setVideoEnabled(true)\n      setVideoTrack(track)\n    }\n  }\n\n  useEffect(() => {\n    // enable video by default\n    createLocalVideoTrack({\n      deviceId: videoDevice?.deviceId,\n    }).then((track) => {\n      setVideoEnabled(true)\n      setVideoTrack(track)\n    })\n  }, [videoDevice])\n\n  const toggleAudio = () => {\n    if (audioEnabled) {\n      setAudioEnabled(false)\n    } else {\n      setAudioEnabled(true)\n    }\n  }\n\n  const selectVideoDevice = (device: MediaDeviceInfo) => {\n    setVideoDevice(device);\n    if (videoTrack) {\n      if (videoTrack.mediaStreamTrack.getSettings().deviceId === device.deviceId) {\n        return\n      }\n      // stop video\n      videoTrack.stop()\n    }\n  }\n\n  const connectToRoom = async () => {\n    if (videoTrack) {\n      videoTrack.stop()\n    }\n\n    if (window.location.protocol === 'https:' &&\n        url.startsWith('ws://') && !url.startsWith('ws://localhost')) {\n      alert('Unable to connect to insecure websocket from https');\n      return\n    }\n\n    const params: {[key: string]: string} = {\n      url,\n      token,\n      videoEnabled: videoEnabled ? '1' : '0',\n      audioEnabled: audioEnabled ? '1' : '0',\n      simulcast: simulcast ? '1' : '0',\n      dynacast: dynacast ? '1' : '0',\n      adaptiveStream: adaptiveStream ? '1' : '0',\n    }\n    if (audioDevice) {\n      params.audioDeviceId = audioDevice.deviceId;\n    }\n    if (videoDevice) {\n      params.videoDeviceId = videoDevice.deviceId;\n    } else if (videoTrack) {\n      // pass along current device id to ensure camera device match\n      const deviceId = await videoTrack.getDeviceId();\n      if (deviceId) {\n        params.videoDeviceId = deviceId;\n      }\n    }\n    history.push({\n      pathname: '/room',\n      search: \"?\" + new URLSearchParams(params).toString()\n    })\n  }\n\n  let videoElement: ReactElement;\n  if (videoTrack) {\n    videoElement = <VideoRenderer track={videoTrack} isLocal={true} />;\n  } else {\n    videoElement = <div className=\"placeholder\"/>\n  }\n\n  return (\n    <div className=\"prejoin\">\n      <main>\n        <h2>LiveKit Video</h2>\n        <hr/>\n        <div className=\"entrySection\">\n          <div>\n            <div className=\"label\">\n              LiveKit URL\n            </div>\n            <div>\n              <input type=\"text\" name=\"url\" value={url} onChange={e => setUrl(e.target.value)} />\n            </div>\n          </div>\n          <div>\n            <div className=\"label\">\n              Token\n            </div>\n            <div>\n              <input type=\"text\" name=\"token\" value={token} onChange={e => setToken(e.target.value)} />\n            </div>\n          </div>\n          <div className=\"options\">\n            <div>\n              <input id=\"simulcast-option\" type=\"checkbox\" name=\"simulcast\" checked={simulcast} onChange={e => setSimulcast(e.target.checked)}/>\n              <label htmlFor=\"simulcast-option\">Simulcast</label>\n            </div>\n            <div>\n              <input id=\"dynacast-option\" type=\"checkbox\" name=\"dynacast\" checked={dynacast} onChange={e => setDynacast(e.target.checked)}/>\n              <label htmlFor=\"dynacast-option\">Dynacast</label>\n            </div>\n            <div>\n              <input id=\"adaptivestream-option\" type=\"checkbox\" name=\"adaptiveStream\" checked={adaptiveStream} onChange={e => setAdaptiveStream(e.target.checked)}/>\n              <label htmlFor=\"adaptivestream-option\">Adaptive Stream</label>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"videoSection\">\n          <AspectRatio ratio={16 / 9}>\n            {videoElement}\n          </AspectRatio>\n        </div>\n\n        <div className=\"controlSection\">\n          <div>\n            <AudioSelectButton\n              isMuted={!audioEnabled}\n              onClick={toggleAudio}\n              onSourceSelected={setAudioDevice}\n              />\n            <VideoSelectButton\n              isEnabled={videoTrack !== undefined}\n              onClick={toggleVideo}\n              onSourceSelected={selectVideoDevice}\n            />\n          </div>\n          <div className=\"right\">\n            <ControlButton\n              label=\"Connect\"\n              disabled={connectDisabled}\n              icon={faBolt}\n              onClick={connectToRoom}/>\n          </div>\n        </div>\n      </main>\n      <footer>\n        This page is built with <a href=\"https://github.com/livekit/livekit-react\">LiveKit React</a>&nbsp;\n        (<a href=\"https://github.com/livekit/livekit-react/blob/master/example/src/PreJoinPage.tsx\">source</a>)\n      </footer>\n    </div>\n  )\n}\n","import { faSquare, faThLarge, faUserFriends } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { Room, RoomEvent, VideoPresets } from 'livekit-client'\nimport { DisplayContext, DisplayOptions, LiveKitRoom } from 'livekit-react'\nimport { useState } from \"react\"\nimport \"react-aspect-ratio/aspect-ratio.css\"\nimport { useHistory, useLocation } from 'react-router-dom'\n\nexport const RoomPage = () => {\n  const [numParticipants, setNumParticipants] = useState(0)\n  const [displayOptions, setDisplayOptions] = useState<DisplayOptions>({\n    stageLayout: 'grid',\n    showStats: false,\n  })\n  const history = useHistory()\n  const query = new URLSearchParams(useLocation().search)\n  const url = query.get('url')\n  const token = query.get('token')\n  const recorder = query.get('recorder')\n\n  if (!url || !token) {\n    return (\n      <div>\n        url and token are required\n      </div>\n    )\n  }\n\n  const onLeave = () => {\n    history.push({\n      pathname: '/',\n    })\n  }\n\n  const updateParticipantSize = (room: Room) => {\n    setNumParticipants(room.participants.size + 1);\n  }\n\n  const onParticipantDisconnected = (room: Room) => {\n    updateParticipantSize(room)\n\n    /* Special rule for recorder */\n    if (recorder && parseInt(recorder, 10) === 1 && room.participants.size === 0) {\n      console.log(\"END_RECORDING\")\n    }\n  }\n\n  const updateOptions = (options: DisplayOptions) => {\n    setDisplayOptions({\n      ...displayOptions,\n      ...options,\n    });\n  }\n\n  return (\n    <DisplayContext.Provider value={displayOptions}>\n      <div className=\"roomContainer\">\n        <div className=\"topBar\">\n          <h2>LiveKit Video</h2>\n          <div className=\"right\">\n            <div>\n              <input id=\"showStats\" type=\"checkbox\" onChange={(e) => updateOptions({ showStats: e.target.checked })} />\n              <label htmlFor=\"showStats\">Show Stats</label>\n            </div>\n            <div>\n              <button\n                className=\"iconButton\"\n                disabled={displayOptions.stageLayout === 'grid'}\n                onClick={() => {\n                  updateOptions({ stageLayout: 'grid' })\n                }}\n              >\n                <FontAwesomeIcon height={32} icon={faThLarge} />\n              </button>\n              <button\n                className=\"iconButton\"\n                disabled={displayOptions.stageLayout === 'speaker'}\n                onClick={() => {\n                  updateOptions({ stageLayout: 'speaker' })\n                }}\n              >\n                <FontAwesomeIcon height={32} icon={faSquare} />\n              </button>\n            </div>\n            <div className=\"participantCount\">\n              <FontAwesomeIcon icon={faUserFriends} />\n              <span>{numParticipants}</span>\n            </div>\n          </div>\n        </div>\n        <LiveKitRoom\n          url={url}\n          token={token}\n          onConnected={room => {\n            onConnected(room, query);\n            room.on(RoomEvent.ParticipantConnected, () => updateParticipantSize(room))\n            room.on(RoomEvent.ParticipantDisconnected, () => onParticipantDisconnected(room))\n            updateParticipantSize(room);\n          }}\n          connectOptions={{\n            adaptiveStream: isSet(query, 'adaptiveStream'),\n            dynacast: isSet(query, 'dynacast'),\n            videoCaptureDefaults: {\n              resolution: VideoPresets.h720.resolution,\n            },\n            logLevel: 'debug',\n          }}\n          onLeave={onLeave}\n        />\n      </div>\n    </DisplayContext.Provider>\n  )\n}\n\nasync function onConnected(room: Room, query: URLSearchParams) {\n  // make it easier to debug\n  (window as any).currentRoom = room;\n\n  if (isSet(query, 'audioEnabled')) {\n    const audioDeviceId = query.get('audioDeviceId');\n    if (audioDeviceId && room.options.audioCaptureDefaults) {\n      room.options.audioCaptureDefaults.deviceId = audioDeviceId;\n    }\n    await room.localParticipant.setMicrophoneEnabled(true);\n  }\n\n  if (isSet(query, 'videoEnabled')) {\n    const videoDeviceId = query.get('videoDeviceId');\n    if (videoDeviceId && room.options.videoCaptureDefaults) {\n      room.options.videoCaptureDefaults.deviceId = videoDeviceId;\n    }\n    await room.localParticipant.setCameraEnabled(true);\n  }\n}\n\nfunction isSet(query: URLSearchParams, key: string): boolean {\n  return query.get(key) === '1' || query.get(key) === 'true';\n}\n","import 'livekit-react/dist/index.css'\nimport { HashRouter as Router, Route, Switch } from 'react-router-dom'\nimport { PreJoinPage } from './PreJoinPage'\nimport { RoomPage } from './RoomPage'\n\nconst App = () => {\n  return (\n    <div className=\"container\">\n      <Router>\n        <Switch>\n          <Route path=\"/room\">\n            <RoomPage/>\n          </Route>\n          <Route path=\"/\">\n            <PreJoinPage/>\n          </Route>\n        </Switch>\n      </Router>\n    </div>\n  )\n}\n\nexport default App\n","import ReactDOM from 'react-dom'\nimport App from './App'\nimport './index.css'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}